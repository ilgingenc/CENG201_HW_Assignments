For Task1:
Big O notation is used to measure how an algorithm's
running time changes depending on the input size.
In this report, I examined the complexities of the addPatient,
removePatient and findPatient methods in the patientList class.
addPatient method adds the patient to the end of the list.
The whole list cannot be circulated in this method.
The time complexity of this method is O(1) because of this reason.
removePatient method goes through the list one by one by providing ID check.
The wanted element may be at the end of the list or not at all.
The time complexity of this method is O(n).
findPatient method goes through the entire list and may not find
it or may be at the end of the list.So, time complexity is O(n).
ArrayList vs Linked List:
for addPatient:Usually both have O(1)
but in ArrayList sometimes it can be O(n)
because the elements are copied when the array is full.
Find process takes O(n) time in linked list and arraylist.
Linked list is more useful in the deletion process.
For this reason, if adding and deleting are more frequent,
the Linked List is more convenient. In conclusion choosing the data
structure is very important.

For Task 2:
The queue data structure is suitable for managing treatment
request in a hospital system. Choosing  the right data structure
ensures that the system operates more efficiently.
The queue structure operates on FIFO principle.
In addition this method is used in bank queues,hospital
queues and bread queues. In hospital system,
the patient who comes first is treated first.
This situation ensures justice among patients.
A priority queue is created for priority patients.
In this way, priority patients are given importance.
Without this separation, emergency situations may be delayed.
This method allows faster treatment of emergency patients.
If stack had been used in this system, it would have caused some problems.
The stack structure works with LIFO logic.
This means that patients who come first
have to wait longer. This system is not correct and logical.
This system creates unfair situations in the hospital environment.
In the queue, operations enqueue() and dequeue()
are performed in O(1) time period.These operations are fast because
elements are added or removed from known position. As a result, queue is
thew right choice. Big O notation is used to describe the time complexity
of algorithm. Since the enqueue() and dequeue() operations
run in O(1) time, the queue structure is efficient for this system.

For Task 3:
First let's start with what Stack is. Stack logic is LIFO.
Meaning is last in,first out. In this task, a stack structure was
used to display discharged patients.The stack structure
works according LIFO logic. This structure is suitable.
It is requested to access the information of the last discharged
patient. When the patient is discharged ,the person's
information is recorded as a Discharge object. For push(),
it is added to the top of the stack. The peek() is used to view
the last discharged patient. If you want to delete the recording,
you can use pop().  If the queue structure were used in this
system, it would cause problems. The queue structure operates
operates according to the FIFO logic. In this case, the record
of the first discharged patient would be processed first.
However, in practice, older discharge records are usually
less important. The hospital takes care of the most up-to-date
discharge information. Therefore, the queue structure does
not make much sense. In a stack implemented using a linked
list, to push,pop and peek operations are performed in
O(1) time.This is important in terms of time complexity.
In a queue structure, the enqueue and dequeue operations
also take O(1) time. So, the stack data  structure is the correct,
simple and logical choice for managing discharge records.

For Task 4:
The logic behind this assignment was to use two separate
queue structure. There is one queue for priority patients
and another queue for normal patients. When a new treatment
request is added, if the patient is priority, it is
added to the priority queue. Otherwise, it is added to the
normal queue. This insertion operation takes O(1) time for
both queues because the element is added directly to the
end of the queue. When processing a treatment request, the
priority queue is checked first. If there is a patient in this
queue, the request is taken from there. Otherwise, it is taken
from normal queue. This operation also takes O(1) time. In this
way, priority patients are taken forward and FIFO logic is
processed. A sorting algorithm was used to sort patients by
severity or waiting time. For small numbers of patients,
Bubble Sort is enough and has an O(n square) time complexity.
For larger patients numbers, using Merge Sort can achieve
faster sorting with O(n log n) complexity. If there are many
priority patients in the system, using a heap-based priority
queue makes operations more efficient. When using a heap, enqueue
and dequeue operations take O(log n) time and all priority patients
can be processed quickly in a single data structure. Therefore,
while two queue approach is simple and sufficient for small and medium
sized systems, the heap-based structure improves performance in large data
sets and when there are many priority patients.

